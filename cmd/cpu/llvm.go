package cpu

import (
	"fmt"
	"os"

	"github.com/Manu343726/cucaracha/pkg/hw/cpu/llvm"
	"github.com/Manu343726/cucaracha/pkg/hw/cpu/mc"
	"github.com/spf13/cobra"
)

var outputFile string
var clangPath string
var inputFile string

// generateLlvmTablegenCmd represents the generateLlvmTablegen command
var generateLlvmTablegenCmd = &cobra.Command{
	Use:   "generateLlvmTablegen",
	Short: "Generate LLVM tablegen descriptor files for the Cucaracha architecture",
	Long: `Cucaracha includes a forked LLVM toolchain implementing the Cucaracha architecture
so that C/C++ code can be run in a cucaracha environment (Interpreter, hardware, etc). This command bootstraps
the tablegen files needed by the LLVM backend to implement code generation for the Cucaracha architecture.

The generated Cucaracha.td file includes:
- Register definitions
- Instruction definitions  
- Condition codes (CPSR flags, condition masks, condition code enums)
- Calling conventions

TableGen then generates C++ code from these definitions, including searchable tables
for condition code lookups.

See https://llvm.org/docs/CodeGenerator.html for more information about LLVM code generation.`,
	Run: func(cmd *cobra.Command, args []string) {
		g, err := llvm.NewGenerator()

		if err != nil {
			fmt.Fprintf(os.Stderr, "error initializing llvm.Generator: %v\n", err)
			os.Exit(1)
		}

		if len(outputFile) == 0 {
			err = g.GenerateTo(os.Stdout)
		} else {
			err = g.Generate(outputFile)
		}

		if err != nil {
			fmt.Fprintf(os.Stderr, "Error generating target descriptor file: %v\n", err)
			os.Exit(2)
		}
	},
}

var clangVersionCmd = &cobra.Command{
	Use:   "clangVersion",
	Short: "Output the clang version used by the Cucaracha toolchain",
	Run: func(cmd *cobra.Command, args []string) {
		driver, err := llvm.NewClangDriver(clangPath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error finding clang: %v\n", err)
			os.Exit(1)
		}

		version, err := driver.Version()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error getting clang version: %v\n", err)
			os.Exit(2)
		}

		fmt.Println(version)
	},
}

var dumpAssemblyCmd = &cobra.Command{
	Use:   "dumpAssembly",
	Short: "Load and dump a .cucaracha assembly file",
	Long: `Parses an LLVM-generated .cucaracha assembly file and outputs a detailed
debugging representation of the program file, including memory layout,
functions, instructions, labels, globals, and symbol references.

This command is useful for debugging and inspecting the parsed representation
of assembly files generated by the Cucaracha LLVM backend.`,
	Run: func(cmd *cobra.Command, args []string) {
		if inputFile == "" {
			fmt.Fprintln(os.Stderr, "Error: input file is required (use -i or --input)")
			os.Exit(1)
		}

		pf, err := llvm.ParseAssemblyFile(inputFile)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing assembly file: %v\n", err)
			os.Exit(2)
		}

		var out *os.File
		if outputFile == "" {
			out = os.Stdout
		} else {
			out, err = os.Create(outputFile)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
				os.Exit(3)
			}
			defer out.Close()
		}

		if err := mc.DumpProgramFile(out, pf); err != nil {
			fmt.Fprintf(os.Stderr, "Error dumping program file: %v\n", err)
			os.Exit(4)
		}
	},
}

func init() {
	CpuCmd.AddCommand(generateLlvmTablegenCmd, clangVersionCmd, dumpAssemblyCmd)
	generateLlvmTablegenCmd.Flags().StringVarP(&outputFile, "output-file", "o", "", "Output file. If omitted, the output will be written to stdout")
	clangVersionCmd.Flags().StringVarP(&clangPath, "clang-path", "p", "", "Full path to the clang executable")
	dumpAssemblyCmd.Flags().StringVarP(&inputFile, "input", "i", "", "Input .cucaracha assembly file to parse")
	dumpAssemblyCmd.Flags().StringVarP(&outputFile, "output", "o", "", "Output file. If omitted, the output will be written to stdout")
}
